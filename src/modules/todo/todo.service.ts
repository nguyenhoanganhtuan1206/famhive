import { BadRequestException, Injectable, Logger } from '@nestjs/common';
import { CommandBus } from '@nestjs/cqrs';
import { InjectRepository } from '@nestjs/typeorm';
import dayjs from 'dayjs';
import _ from 'lodash';
import { I18nContext, I18nService } from 'nestjs-i18n';
import { RRule } from 'rrule';
import { ILike, In, IsNull, LessThan, MoreThan, Repository } from 'typeorm';
import { Transactional } from 'typeorm-transactional';

import { dateFormat, RoleType } from '../../constants';
import { AwardHistoryType } from '../../constants/award-history-type';
import { ScheduleService } from '../../shared/services/schedule.service';
import { delay } from '../../utils/delay.utils';
import { calculateRruleString } from '../../utils/rrule.utils';
import { SendMailCommand } from '../mailer/commands/send-mail.command';
import { AddAwardHistoryCommand } from '../reward/commands/add-award-history.command';
import { DecreaseRewardForUsersCommand } from '../reward/commands/decrease-reward-for-users.command';
import { IncreaseRewardForUserCommand } from '../reward/commands/increase-reward-for-user.command';
import type { CreateAwardHistoryDto } from '../reward/dto/create-award-history.dto';
import { FindUsersByCommand } from '../user/commands/find-user-by.command';
import { GetAdminsActivatedByListFamilyIdsCommand } from '../user/commands/get-admins-activated-by-list-family-ids.command';
import { UserEntity } from '../user/user.entity';
import { FindOneCategoryCommand } from './commands/find-one-category.command';
import type {
  CreateAutoGeneratedTodoDto,
  CreateTodoDto,
} from './dto/create-todo.dto';
import { TodoDto } from './dto/todo.dto';
import type { UpdateTodoDto } from './dto/update-todo.dto';
import { TodoEntity } from './entities/todo.entity';
import type { ActionPlanType } from './types/action-plan.type';
import type { ISummaryAward } from './types/summary-award';
import { TodoType } from './types/todo.type';

const MAIL_PARTITION_SIZE = 100;
const DELAY_TIME_BETWEEN_PARTITION = 5 * 1000;

@Injectable()
export class TodoService {
  constructor(
    @InjectRepository(TodoEntity)
    private todoRepository: Repository<TodoEntity>,
    private commandBus: CommandBus,
    private i18nService: I18nService,
    private scheduleService: ScheduleService,
  ) {}

  async create(
    user: UserEntity,
    createTodoDto: CreateTodoDto | CreateAutoGeneratedTodoDto,
  ) {
    if (createTodoDto.type === TodoType.BUY && createTodoDto.award) {
      throw new BadRequestException(
        `Award should not be more than 0 if type is ${TodoType.BUY}`,
      );
    }

    // todo: remove later
    // support for old version
    if (createTodoDto.assigneeId) {
      createTodoDto.assigneeIds = [createTodoDto.assigneeId];
    }

    let assignees: UserEntity[] = [];

    if (_.size(createTodoDto.assigneeIds) > 0) {
      assignees = await this.commandBus.execute(
        new FindUsersByCommand({
          id: In(createTodoDto.assigneeIds),
        }),
      );

      if (assignees.length < createTodoDto.assigneeIds.length) {
        throw new BadRequestException('Some assignees are incorrect!');
      }
    }

    if (createTodoDto.categoryId) {
      // Verify category exist or not
      await this.commandBus.execute(
        new FindOneCategoryCommand(createTodoDto.categoryId, user.familyId),
      );
    }

    const todo = this.todoRepository.create({
      ...createTodoDto,
      familyId: user.familyId,
      assignees,
    });

    if (todo.isRecurring) {
      todo.rrule = calculateRruleString(
        todo.recurringType,
        todo.dueDate || new Date(),
        todo.untilDateTime,
        todo.byWeekDay,
      );
    }

    const newTodo = new TodoDto(await this.todoRepository.save(todo));

    if (todo.isRecurring) {
      this.addAutoGenTodoCronJob(todo);
    }

    return newTodo;
  }

  async findAll(user: UserEntity) {
    const todos = await this.todoRepository.find({
      where: {
        familyId: user.familyId,
      },
      order: {
        dueDate: 'asc',
        createdAt: 'asc',
      },
      relations: {
        assignees: true,
      },
    });

    return todos.map((x) => x.toDto());
  }

  async findOverdue(user: UserEntity) {
    const todos = await this.todoRepository.find({
      where: {
        familyId: user.familyId,
        isDone: false,
        dueDate: LessThan(new Date()),
      },
      order: {
        dueDate: 'ASC',
      },
      relations: {
        assignees: true,
      },
    });

    return todos.map((x) => x.toDto());
  }

  private async getOverdueTasks() {
    return this.todoRepository.find({
      where: {
        isDone: false,
        dueDate: LessThan(new Date()),
      },
      relations: {
        assignees: true,
      },
      order: {
        dueDate: 'asc',
      },
    });
  }

  async sendOverdueTasksToCorrespondingEmail() {
    // get all overdue tasks
    const overdueTasks = await this.getOverdueTasks();

    // group tasks by family id
    const group = _.groupBy(overdueTasks, 'familyId');
    const familyIds = _.uniq(_.map(overdueTasks, 'familyId'));

    // get users, whose have overdue tasks
    const users = await this.getAdminsActivatedByFamilyIds(familyIds);
    const usersChunked = _.chunk(users, MAIL_PARTITION_SIZE);
    Logger.log(`Start sendOverdueTasksToCorrespondingEmail`);
    Logger.log(`Total email will be sent: ${users.length}`);

    for (const [index, chunk] of usersChunked.entries()) {
      Logger.log(`Send chunk ${index} of ${usersChunked.length} chunks`);
      // eslint-disable-next-line no-await-in-loop
      await this.sendNotifications(chunk, group);
      // eslint-disable-next-line no-await-in-loop
      await delay(DELAY_TIME_BETWEEN_PARTITION);
    }

    Logger.log(`Send Overdue Tasks To Corresponding Email - DONE`);
  }

  private async sendNotifications(
    users: UserEntity[],
    group: _.Dictionary<TodoEntity[]>,
  ) {
    Logger.log(`Sending mail with size ${users.length}`);

    await Promise.all(
      users.map(async (user) => {
        const userOverdueTasks = _.take(group[user.familyId], 5);
        const totalUserOverdueTasks = _.size(group[user.familyId]);
        await this.commandBus.execute(
          new SendMailCommand({
            to: user.email,
            subject: 'Remind Overdue Tasks',
            templateName: 'overdue-tasks',
            data: {
              fullName: user.fullName,
              remainingOverdueTask:
                totalUserOverdueTasks > 5 ? totalUserOverdueTasks - 5 : 0,
              overdueTasks: userOverdueTasks.map((task) => ({
                text: task.text,
                dueDate: dayjs(task.dueDate).format(dateFormat),
                award: task.award,
                assignee: _.join(
                  _.map(_.get(task, 'assignees'), 'fullName'),
                  ', ',
                ),
              })),
            },
          }),
        );
      }),
    );
    Logger.log(`Sent mail DONE`);
  }

  private async getAdminsActivatedByFamilyIds(
    familyIds: Uuid[],
  ): Promise<UserEntity[]> {
    return this.commandBus.execute(
      new GetAdminsActivatedByListFamilyIdsCommand(familyIds),
    );
  }

  async findAllByType(user: UserEntity, type: TodoType) {
    const todos = await this.todoRepository.find({
      where: {
        familyId: user.familyId,
        type,
      },
      order: {
        dueDate: 'asc',
        createdAt: 'asc',
      },
      relations: {
        assignees: true,
      },
    });

    return todos.map((x) => x.toDto());
  }

  async findOne(user: UserEntity, id: Uuid) {
    return new TodoDto(await this.findEntity(user.familyId, id));
  }

  async update(user: UserEntity, id: Uuid, updateTodoDto: UpdateTodoDto) {
    const todo = await this.findEntity(user.familyId, id, true);

    if (todo.type === TodoType.BUY && updateTodoDto.award) {
      throw new BadRequestException(
        `Award should not be more than 0 if type is ${TodoType.BUY}`,
      );
    }

    // task is finished, and you try to update task info => throw error
    if (todo.isDone) {
      if (updateTodoDto.isDone) {
        throw new BadRequestException(`Task is already finished`);
      }

      // don't allow update isDone and award at the same time
      if (
        updateTodoDto.award !== undefined &&
        updateTodoDto.award !== todo.award
      ) {
        throw new BadRequestException(
          `You should redo task before update award`,
        );
      }
    }

    await this.updateRewardSummaries(user, todo, updateTodoDto);

    // todo: remove later
    // update assignees
    if (updateTodoDto.assigneeId) {
      updateTodoDto.assigneeIds = [updateTodoDto.assigneeId];
    }

    if (updateTodoDto.assigneeIds) {
      todo.assignees = await this.findAssignees(updateTodoDto.assigneeIds);
    }

    const isDoneStatusBefore = todo.isDone;
    this.todoRepository.merge(todo, updateTodoDto);

    if (todo.isRecurring) {
      todo.rrule = calculateRruleString(
        todo.recurringType,
        todo.dueDate || new Date(),
        todo.untilDateTime,
        todo.byWeekDay,
      );
      this.autoGenTodoWhenUpdateTodo(isDoneStatusBefore, todo);
    }

    return new TodoDto(await this.todoRepository.save(todo));
  }

  async updateByKid(user: UserEntity, id: Uuid, updateTodoDto: UpdateTodoDto) {
    // Kid is only able to mark task as Done or NotDone
    const todo = await this.findEntity(user.familyId, id, true);

    if (!this.isAssigneeOfTodo(todo, user)) {
      throw new BadRequestException(`You are not assigned to this task`);
    }

    if (todo.isDone) {
      if (todo.award > 0 && updateTodoDto.isDone === false) {
        throw new BadRequestException(`Unable to undo task with reward!`);
      }

      if (updateTodoDto.isDone) {
        throw new BadRequestException(`Task is already finished`);
      }
    }

    if (updateTodoDto.isDone) {
      await this.updateRewardSummaries(user, todo, updateTodoDto);
    }

    return new TodoDto(
      await this.todoRepository.save({
        ...todo,
        isDone: updateTodoDto.isDone,
      }),
    );
  }

  async findAssignees(assigneeIds: Uuid[]) {
    if (_.isEmpty(assigneeIds)) {
      return [];
    }

    // find assignees
    const assignees = await this.commandBus.execute(
      new FindUsersByCommand({
        id: In(assigneeIds),
      }),
    );

    if (assignees.length < assigneeIds.length) {
      throw new BadRequestException('Some assignees are incorrect!');
    }

    return assignees;
  }

  async suggestNames(user: UserEntity, type: TodoType, textSearch?: string) {
    const textSearchQuery = _.join(
      _.map(_.split(textSearch, /\s+/), (str) => `%${str}%`),
      '',
    );
    const todos = await this.todoRepository
      .createQueryBuilder('todo')
      .select('DISTINCT(text)', 'text')
      .where({
        familyId: user.familyId,
        type,
        text: ILike(textSearchQuery),
        actionPlan: IsNull(),
      })
      .orderBy({
        text: 'ASC',
      })
      .getRawMany();

    return todos.map((x) => x.text);
  }

  async suggestShoppingList(user: UserEntity, textSearch?: string) {
    const shoppingListInDB = await this.suggestNames(
      user,
      TodoType.BUY,
      textSearch,
    );

    // create regex search
    const textSearchQuery = _.join(_.split(textSearch, /\s+/), '.*');
    const regexPattern = new RegExp(_.toLower(textSearchQuery));

    // filter
    const shoppingListDefaultFilter = _.filter(
      this.loadShoppingListDefault(),
      (item) => regexPattern.test(_.toLower(item)),
    );

    return _.uniq([...shoppingListInDB, ...shoppingListDefaultFilter]);
  }

  private loadShoppingListDefault(): string[] {
    return this.i18nService.t('shopping-list-default', {
      lang: I18nContext.current()?.lang,
    });
  }

  private async updateRewardSummaries(
    user: UserEntity,
    todo: TodoEntity,
    updateTodoDto: UpdateTodoDto,
  ) {
    if (
      todo.award > 0 &&
      updateTodoDto.isDone !== undefined &&
      todo.isDone !== updateTodoDto.isDone
    ) {
      // eslint-disable-next-line unicorn/prefer-ternary
      if (updateTodoDto.isDone) {
        // before todo is finished, create update reward summary
        await Promise.all(
          todo.assignees.map((assignee) =>
            this.increaseRewardForUserAndAddHistory(user, assignee.id, todo),
          ),
        );
      } else {
        // check and decrease award before undo task
        if (todo.isDone) {
          const assigneeIds = _.map(todo.assignees, (x) => x.id);
          await this.decreaseRewardForUsersAndAddHistory(
            user,
            assigneeIds,
            todo,
          );
        }
      }
    }
  }

  private async increaseRewardForUserAndAddHistory(
    user: UserEntity,
    assigneeId: Uuid,
    todo: TodoEntity,
  ) {
    await this.increaseRewardForUser(assigneeId, todo.award);

    // Add history when finished todo
    await this.addAwardHistoryForUser(
      user.id,
      assigneeId,
      AwardHistoryType.EARNED,
      todo,
    );
  }

  private async increaseRewardForUser(assigneeId: Uuid, amount: number) {
    await this.commandBus.execute(
      new IncreaseRewardForUserCommand(assigneeId, amount),
    );
  }

  // check and decrease num of start before redo task
  private async decreaseRewardForUsersAndAddHistory(
    user: UserEntity,
    assigneeIds: Uuid[],
    todo: TodoEntity,
  ) {
    await this.commandBus.execute(
      new DecreaseRewardForUsersCommand(assigneeIds, todo.award),
    );

    // Revoked award when redo task
    await Promise.all(
      assigneeIds.map((assigneeId) =>
        this.addAwardHistoryForUser(
          user.id,
          assigneeId,
          AwardHistoryType.REVOKED,
          todo,
        ),
      ),
    );
  }

  private async addAwardHistoryForUser(
    createdById: Uuid,
    assigneeId: Uuid,
    historyType: AwardHistoryType,
    todo: TodoEntity,
  ) {
    const awardHistory: CreateAwardHistoryDto = {
      amount: todo.award,
      description: todo.text,
      userId: assigneeId,
      todoId: todo.id,
      type: historyType,
    };
    await this.commandBus.execute(
      new AddAwardHistoryCommand(createdById, awardHistory),
    );
  }

  async remove(user: UserEntity, id: Uuid) {
    const todo = await this.findEntity(user.familyId, id);

    await this.todoRepository.delete(todo.id);
  }

  private async findEntity(
    familyId: Uuid | undefined,
    id: Uuid,
    findAssignees = false,
  ) {
    return this.todoRepository.findOneOrFail({
      where: { id, familyId },
      relations: {
        assignees: findAssignees,
      },
    });
  }

  async finishAutoGeneratedTask(familyId: Uuid, actionPlan: ActionPlanType) {
    const todo = await this.todoRepository.findOne({
      where: {
        familyId,
        isAutoGenerated: true,
        actionPlan,
        isDone: false,
      },
    });

    if (todo) {
      todo.isDone = true;

      await this.todoRepository.save(todo);
    }
  }

  findTodosFinishedByCategory(categoryId: Uuid) {
    return this.todoRepository.findBy({
      categoryId,
      isDone: true,
    });
  }

  async removeTodosDoneByType(user: UserEntity, type: TodoType) {
    await this.todoRepository.delete({
      isDone: true,
      type,
      familyId: user.familyId,
    });
  }

  @Transactional()
  async checkAllTodos(user: UserEntity, type: TodoType) {
    // find and check all todos that have star
    const summaryAwards = await this.todoRepository
      .createQueryBuilder('todo')
      .leftJoinAndSelect('todo.assignees', 'assignees')
      .select('users_id', 'userId')
      .addSelect('SUM(award)', 'amount')
      .where('todo.type = :type', { type })
      .andWhere('todo.familyId = :familyId', { familyId: user.familyId })
      .andWhere('todo.isDone = false')
      .andWhere('todo.award > 0')
      .groupBy('users_id')
      .getRawMany<ISummaryAward>();

    const todos = await this.todoRepository.find({
      where: {
        type,
        familyId: user.familyId,
        isDone: false,
        award: MoreThan(0),
      },
      relations: {
        assignees: true,
      },
    });

    // add score histories
    await Promise.all(
      todos
        .filter((todo) => this.isAssigneeOfTodo(todo, user))
        .filter((todo) => _.size(todo.assignees) > 0)
        .map((todo) =>
          Promise.all(
            todo.assignees.map((assignee) =>
              this.addAwardHistoryForUser(
                user.id,
                assignee.id,
                AwardHistoryType.EARNED,
                todo,
              ),
            ),
          ),
        ),
    );

    // update reward for users
    await Promise.all(
      summaryAwards.map((summaryAward) =>
        this.increaseRewardForUser(
          summaryAward.userId,
          _.toNumber(summaryAward.amount),
        ),
      ),
    );

    const notDoneTodos = await this.todoRepository.find({
      where: {
        type,
        familyId: user.familyId,
        isDone: false,
      },
      relations: {
        assignees: true,
      },
    });
    await Promise.all(
      notDoneTodos.map(async (todo) => {
        if (user.role !== RoleType.KID || this.isAssigneeOfTodo(todo, user)) {
          await this.todoRepository.save({
            ...todo,
            isDone: true,
          });

          if (todo.rrule) {
            const nextDueDate = this.getNextDueDateByRrule(todo.rrule);
            const nextCronjobDueDate = this.getCronTimeFromDueDate(nextDueDate);

            if (dayjs().isBefore(nextCronjobDueDate)) {
              this.scheduleService.removeCronjob(
                this.generateTodoCronjobName(todo.id),
              );
              await this.generateTodo(todo);
            }
          }
        }
      }),
    );
  }

  async uncheckAllTodos(user: UserEntity, type: TodoType) {
    // only uncheck todos that award is 0

    if (user.role === RoleType.KID) {
      const doneTodos = await this.todoRepository.find({
        where: {
          type,
          familyId: user.familyId,
          award: 0,
          isDone: true,
        },
        relations: {
          assignees: true,
        },
      });

      await Promise.all(
        doneTodos.map((todo) =>
          this.isAssigneeOfTodo(todo, user)
            ? this.todoRepository.save({ ...todo, isDone: false })
            : this.todoRepository.save(todo),
        ),
      );
    } else {
      await this.todoRepository.update(
        {
          type,
          familyId: user.familyId,
          isDone: true,
          award: 0,
        },
        {
          isDone: false,
        },
      );
    }
  }

  private isAssigneeOfTodo(todo: TodoEntity, user: UserEntity) {
    return _.some(todo.assignees, (assignee) => assignee.id === user.id);
  }

  private addAutoGenTodoCronJob(todo: TodoEntity) {
    const newTodo = this.getAutoGenerateTodo(todo);

    if (!newTodo || !newTodo.dueDate) {
      return;
    }

    const jobName = this.generateTodoCronjobName(todo.id);
    const cronTime = this.getCronTimeFromDueDate(newTodo.dueDate);
    this.scheduleService.addCronJob(
      jobName,
      cronTime,
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      async () => new TodoDto(await this.todoRepository.save(newTodo)),
    );
  }

  private getCronTimeFromDueDate(dueDate: Date) {
    return dayjs(dueDate).set('hour', 0).set('minute', 0).set('second', 0);
  }

  private async generateTodo(todo: TodoEntity) {
    const newTodo = this.getAutoGenerateTodo(todo);

    if (!newTodo) {
      return;
    }

    void new TodoDto(await this.todoRepository.save(newTodo));
  }

  private getNextDueDateByRrule(rrule: string) {
    const rule = RRule.fromString(rrule);

    // It is the next day of recurring
    return rule.all(function (date, i) {
      return i < 2;
    })[1];
  }

  private getAutoGenerateTodo(todo: TodoEntity) {
    if (!todo.rrule) {
      return;
    }

    const dueDate = this.getNextDueDateByRrule(todo.rrule);

    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (!dueDate) {
      return;
    }

    const rrule = calculateRruleString(
      todo.recurringType,
      dueDate,
      todo.untilDateTime,
      todo.byWeekDay,
    );

    return this.todoRepository.create({
      ...todo,
      id: undefined,
      isDone: false,
      dueDate,
      rrule,
    });
  }

  private generateTodoCronjobName(id: Uuid) {
    return `generateTodoCronjob_${id}`;
  }

  private autoGenTodoWhenUpdateTodo(
    isDoneStatusBefore: boolean,
    newTodo: TodoEntity,
  ) {
    if (newTodo.isDone && !isDoneStatusBefore) {
      void this.generateTodo(newTodo);
    }

    if (!newTodo.isDone && !isDoneStatusBefore) {
      this.scheduleService.removeCronjob(
        this.generateTodoCronjobName(newTodo.id),
      );
      this.addAutoGenTodoCronJob(newTodo);
    }
  }
}
